const int mic1 = A0;
const float Pi2 = 6.2831853;
uint32_t t0, t;
const uint16_t samples = 256;
volatile uint16_t rawInputArray[samples]={}; 
volatile uint16_t sampleNum = 0;
const uint16_t N = 256;
const float Pi2N = Pi2/N;
const uint8_t kstart = 10;  //beginning frequency is kstart*fs/N
const uint8_t kend = 60;    //ending frequency is kend*fs/N
const uint8_t kdiff = kend - kstart;
float coslookup[N] = {};
float sinlookup[N] = {};

void setupADC(){
  ADC->CTRLA.bit.ENABLE = 0;                     // Disable ADC
  while( ADC->STATUS.bit.SYNCBUSY == 1 );        // Wait for synchronization
  ADC->CTRLB.reg = ADC_CTRLB_PRESCALER_DIV256 |  // Divide Clock by 256, 10.461kHz
                   ADC_CTRLB_RESSEL_12BIT;       // Result on 12 bits
  ADC->AVGCTRL.reg = ADC_AVGCTRL_SAMPLENUM_1 |   // 1 sample
                     ADC_AVGCTRL_ADJRES(0x00ul); // Adjusting result by 0
  ADC->SAMPCTRL.reg = 0x00;                      // Sampling Time Length = 0
  ADC->CTRLA.bit.ENABLE = 1;                     // Enable ADC
  while( ADC->STATUS.bit.SYNCBUSY == 1 );        // Wait for synchronization
  analogReadResolution(12);
}

void setup() {
  setupADC();
  Serial.begin(115200);   //begin serial communication
  delay(500);             //wait for ADC to stabilize
  populateLookup();       //populate sin and cos lookup tables
}

void loop() {
  //initialize arrays to hold real, imag, and abs DFT values. Length is kend-kstart
  float rawInputArrayReal[kdiff] = {};
  float rawInputArrayImag[kdiff] = {};
  float rawInputArrayAbs[kdiff] = {};
  uint16_t modval;
  float cosval;
  float sinval;
  float maximum = 0;
  uint8_t index = 0;
  delay(100);
  //Serial.println("GO");   //inidicates start of DFT
  
  //t0 = millis();
  readMic1();
  //t = millis()-t0;
  //Serial.println(t);
  
  //DFT
  for (int k = 0; k < kdiff; k++){
    for (int i = 0; i < samples; i++) {
      modval = i*(k+kstart) % N;
      /*
      cosval = cos(Pi2N*modval);
      sinval = sqrt( 1 - sq(cosval) );
      if ( modval > 128 ) {
        sinval = -sinval;
      }
      */
      rawInputArrayReal[k] = rawInputArrayReal[k] + (rawInputArray[i] * coslookup[modval]);
      rawInputArrayImag[k] = rawInputArrayImag[k] + (rawInputArray[i] * sinlookup[modval]);
    }
    rawInputArrayAbs[k] = sqrt( sq(rawInputArrayReal[k]) + sq(rawInputArrayImag[k]) );
  }
  //t = millis()-t0;
  //Serial.println(t);
  
  //finding maximum frequency bin
  for (int i = 0; i < kdiff; i++) {
    if (rawInputArrayAbs[i] > maximum) {
      maximum = rawInputArrayAbs[i];
      index = i;
    }
  }
  //t = millis()-t0;
  //Serial.println(t);

  /*
  for (int i = 0; i < kdiff; i++) {
    Serial.println(rawInputArrayAbs[i]);
  }
  */
  //printrawInputArray();
  //Serial.println("STOOOOOOP");
  Serial.println((index+kstart)*40.86328125);
}

//Populate cos and sin lookup table
void populateLookup(){
  for (int i = 0; i < N; i++){
    coslookup[i] = cos(Pi2N*i);
    sinlookup[i] = sin(Pi2N*i);
  }
}

//Fill array with mic1 input
void readMic1(){
  while (sampleNum < samples) {
    rawInputArray[sampleNum] = analogRead(mic1);
    sampleNum++;
  }
  sampleNum = 0;
}

//Print values of raw input array
void printrawInputArray(){
  for (int i = 0; i < samples; i++) {
    Serial.println(rawInputArray[i]);
  }
}
